#! /usr/bin/env python

"""Create a grid to use with tileskymap

This script creates an all-sky grid for a given field of view, or
creates a grid from an input file with right ascension and declination
pointings, and a given field of view.

For the first case, the full sky will be gridded into areas; by
default, areas overlap by half their size in right ascension, and half
their size in declination. This allows for the necessary flexibility
when tiling a set of pointings.

The overlap can be changed with the --ra-overlap and --dec-overlap,
which represents the fraction of overlap.

For the second case, a two-column (white-space separated) text file
should given next to the field of view, with the first column the
right ascension (in degrees between 0 and 360) and the second colunm
the declination (between -90 and 90). Each rows thus represents a
pointing on the sky.

"""

import os
import sys
import argparse
import pydoc
import gzip
import pickle
import logging
import inspect
import numpy as np
from astropy import units
from astropy.coordinates import SkyCoord
from gototile.grid import tileallsky
import gototile.telescope


class HelpAction(argparse.Action):
    """Help that pages the doc string when the long option is used
    (compare for example git)"""
    def __call__(self, parser, namespace, values, option_string=None):
        if option_string == '-h':
            parser.print_help()
            parser.exit()
        elif option_string == '--help':
            pydoc.pager(__doc__)
            parser.exit()


def get_telescopes():
    """Return the predefined telescopes and their class names"""
    predicate = (lambda item: inspect.isclass(item) and
                 issubclass(item, gototile.telescope.Telescope) and
                 item is not gototile.telescope.Telescope)
    telescopes = dict(inspect.getmembers(gototile.telescope, predicate))
    return telescopes


def parse_args():
    telescopes = get_telescopes()
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter, add_help=False)
    parser.add_argument('output',
                        help="Output file name to store grid")
    parser.add_argument('--fov-ra', type=float,
                        help="Field-of-view along the Right Ascension, "
                        "in degrees")
    parser.add_argument('--fov-dec', type=float,
                        help="Field-of-view along the declination, "
                        "in degrees")
    parser.add_argument('--telescope', choices=list(telescopes.keys()),
                        action='append',
                        help="Select from pre-defined telescopes. "
                        "Can be used multiple times. "
                        "If one of --fov-ra/dec is used, overrides that "
                        "telescope parameter.")
    parser.add_argument('--pointings',
                        help="CSV pointing file (rows of 'ra dec' in degrees. "
                        "Optionally provide a 'name' column)")
    parser.add_argument('--overlap-ra', type=float, default=0.5,
                        help="Amount of overlap between tiles along the RA. "
                        "Ignored when given a pointing file")
    parser.add_argument('--overlap-dec', type=float, default=0.5,
                        help="Amount of overlap between tiles along the "
                        "declination. Ignored when given a pointing file")
    parser.add_argument('--nside', action='append', type=int,
                        help="'nside' parameter to calculate the HEALPIX "
                        "pixels per in a tile. Can be used multiple times.")
    parser.add_argument('-f', '--force', action='store_true',
                        help="Overwrite existing output file")
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Verbose level")
    parser.add_argument('-h', '--help', nargs=0, action=HelpAction,
                        help="Display this help and exit")
    args = parser.parse_args()
    if args.fov_ra and not (0 < args.fov_ra <= 180):
        parser.error("fov-ra should be between 0 and 180")
    if args.fov_dec and not (0 < args.fov_dec <= 90):
        parser.error("fov-dec should be between 0 and 90")
    if args.overlap_ra is not None:
        if not (0 < args.overlap_ra <= 0.9):
            parser.error("--overlap-ra should be between 0 and 0.9")
    if args.overlap_dec is not None:
        if not (0 < args.overlap_dec <= 0.9):
            parser.error("--overlap-dec should be between 0 and 0.9")
    if args.nside is None:
        args.nside = [256]
    args.telescopes = []
    if args.telescope:
        for i, name in enumerate(args.telescope):
            tel = telescopes[name]()
            if args.fov_ra is not None:
                tel.fov['ra'] = args.fov_ra * units.degree
            if args.fov_dec is not None:
                tel.fov['dec'] = args.fov_dec * units.degree
            args.telescopes.append(tel)
        # fov_ra/dec are now irrelevant
        args.fov_ra = None
        args.fov_dec = None
    elif args.fov_ra is None or args.fov_dec is None:
        parser.error("specify a --telescope, or both --fov-ra and --fov-dec")
    return args


def create_gridfile(nside, fov, overlap, filename, force=False,
                    pointings=None, names=None):
    """Create and write a file with a sky grid

    A set of pointings can be given as a SkyCoord array. When not
    given, the full sky is gridded.

    The grid is dependent on the field of view. When there are no
    pointings passed to the function, the field of view in combination
    with the overlap parameter, sets the gridding in RA and dec.

    Parameters
    ----------

    nside : int

        HEALPix nside (resolution) parameter. Usual values are 128, 256 or 512.

    fov : dict with 'ra' and 'dec' keys

        Field of view along RA and dec

    overlap : dict with 'ra' and 'dec' keys

        Amount of overlap between tiles, along RA and dec. Should be a
        value between 0 and 0.9 for each direction.

    force : bool (default: False)

        Overwrite output file if it exists

    pointings : SkyCoord (default: None)

        List of pointings. If None, grid the full sky

    """

    if not filename.endswith('.pgz'):
        filename += '.pgz'

    if not force and os.path.lexists(filename):
        sys.exit("{} already exists; not overwritten".format(filename))

    logging.debug("Tiling for nside = %d", nside)
    tiles = tileallsky(
            fov, nside, overlap=overlap, gridcoords=pointings, nested=True)
    if names is None:
        names = np.arange(len(tiles[0]))+1
    tiles = (names,) + tiles
    logging.debug("Writing %s", filename)
    with gzip.GzipFile(filename, 'w', compresslevel=5) as fp:
        pickle.dump(tiles, fp, protocol=2)
    logging.debug("Finished writing %s", filename)


def main():
    args = parse_args()
    logging.basicConfig(level=['WARNING', 'INFO', 'DEBUG'][args.verbose],
                        format='%(asctime)s [%(levelname)s]: %(message)s',
                        datefmt='%Y-%m-%dT%H:%M:%S')
    fov = {'ra': args.fov_ra * units.degree if args.fov_ra else None,
           'dec': args.fov_dec * units.degree if args.fov_dec else None}
    overlap = {'ra': args.overlap_ra, 'dec': args.overlap_dec}

    names = None
    if args.pointings:
        pointings = np.genfromtxt(
            args.pointings, dtype=None, names=True, delimiter=',')
        try:
            names = pointings['name']
            names = [name.decode('ascii') for name in names]
        except ValueError:
            pass
        pointings = SkyCoord(ra=pointings['ra'], dec=pointings['dec'],
                             unit=units.degree)
    else:
        pointings = None

    dirname, filename = os.path.split(args.output)
    if args.telescopes:
        for telescope in args.telescopes:
            fov['ra'] = telescope.fov['ra']
            fov['dec'] = telescope.fov['dec']
            for nside in args.nside:
                pathname = "{}_nside{}_{}".format(telescope.name, nside,
                                                  filename)
                pathname = os.path.join(dirname, pathname)

                create_gridfile(nside, fov, overlap, pathname, args.force,
                                pointings=pointings, names=names)

    else:
        for nside in args.nside:
            if len(args.nside) > 1:
                pathname = "nside{}_{}".format(nside, filename)
                pathname = os.path.join(dirname, pathname)
            else:
                pathname = args.output
            create_gridfile(nside, fov, overlap, pathname, args.force,
                            pointings=pointings, names=names)


if __name__ == "__main__":
    main()
