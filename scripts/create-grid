#! /usr/bin/env python

"""Create a grid to use with tileskymap

This script creates an all-sky grid for a given field of view, or
creates a grid from an input file with right ascension and declination
pointings, and a given field of view.

For the first case, the full sky will be gridded into areas; by
default, areas overlap by half their size in right ascension, and half
their size in declination. This allows for the necessary flexibility
when tiling a set of pointings.

The overlap can be changed with the --ra-overlap and --dec-overlap,
which represents the fraction of overlap.

For the second case, a two-column (white-space separated) text file
should given next to the field of view, with the first column the
right ascension (in degrees between 0 and 360) and the second colunm
the declination (between -90 and 90). Each rows thus represents a
pointing on the sky.

"""

import os
import sys
import argparse
import pydoc
import gzip
import pickle
import logging
import inspect
import numpy as np
from astropy import units
from astropy.coordinates import SkyCoord
from gototile.grid import tileallsky2
import gototile.telescope


class HelpAction(argparse.Action):
    """Help that pages the doc string when the long option is used
    (compare for example git)"""
    def __call__(self, parser, namespace, values, option_string=None):
        if option_string == '-h':
            parser.print_help()
            parser.exit()
        elif option_string == '--help':
            pydoc.pager(__doc__)
            parser.exit()


def get_telescopes():
    """Return the predefined telescopes and their class names"""
    predicate = (lambda item: inspect.isclass(item) and
                 issubclass(item, gototile.telescope.Telescope) and
                 item is not gototile.telescope.Telescope)
    telescopes = dict(inspect.getmembers(gototile.telescope, predicate))
    return telescopes


def parse_args():
    telescopes = get_telescopes()
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter, add_help=False)
    parser.add_argument('output',
                        help="Output file name to store grid")
    parser.add_argument('--fov-ra', type=float,
                        help="Field-of-view along the Right Ascension, "
                        "in degrees")
    parser.add_argument('--fov-dec', type=float,
                        help="Field-of-view along the declination, "
                        "in degrees")
    parser.add_argument('--telescope', choices=list(telescopes.keys()),
                        action='append',
                        help="Select from pre-defined telescopes. "
                        "Can be used multiple times. "
                        "If one of --fov-ra/dec is used, overrides that "
                        "telescope parameter.")
    parser.add_argument('--pointings',
                        help="Pointing file (rows of 'ra dec' in degrees)")
    parser.add_argument('--ra-overlap', type=float, default=0.5,
                        help="Amount of overlap between tiles along the RA. "
                        "Ignored when given a pointing file")
    parser.add_argument('--dec-overlap', type=float, default=0.5,
                        help="Amount of overlap between tiles along the "
                        "declination. Ignored when given a pointing file")
    parser.add_argument('--nside', action='append', type=int,
                        help="'nside' parameter to calculate the HEALPIX "
                        "pixels per in a tile. Can be used multiple times.")
    parser.add_argument('-f', '--force', action='store_true',
                        help="Overwrite existing output file")
    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Verbose level")
    parser.add_argument('-h', '--help', nargs=0, action=HelpAction,
                        help="Display this help and exit")
    args = parser.parse_args()
    if args.fov_ra and not (0 < args.fov_ra <= 180):
        parser.error("fov-ra should be between 0 and 180")
    if args.fov_dec and not (0 < args.fov_dec <= 90):
        parser.error("fov-dec should be between 0 and 90")
    if args.ra_overlap is not None:
        if not (0 < args.ra_overlap <= 0.9):
            parser.error("--ra-overlap should be between 0 and 0.9")
    if args.dec_overlap is not None:
        if not (0 < args.dec_overlap <= 0.9):
            parser.error("--dec-overlap should be between 0 and 0.9")
    if args.nside is None:
        args.nside = [256]
    args.telescopes = []
    if args.telescope:
        for i, name in enumerate(args.telescope):
            tel = telescopes[name]()
            if args.fov_ra is not None:
                tel.fov['ra'] = args.fov_ra * units.degree
            if args.fov_dec is not None:
                tel.fov['dec'] = args.fov_dec * units.degree
            args.telescopes.append(tel)
        # fov_ra/dec are now irrelevant
        args.fov_ra = None
        args.fov_dec = None
    elif args.fov_ra is None or args.fov_dec is None:
        parser.error("specify a --telescope, or both --fov-ra and --fov-dec")
    return args


def create_gridfile(nsides, fov, overlap, filename, force=False,
                    pointings=None):
    """Create and write a file with a sky grid

    The sky grid file contains a dict of grids: one grid for each
    nside given in nsides. Note that only the pixel list will differ:
    the tilelist and grid coordinates are the same for each grid.

    A set of pointings can be given as a SkyCoord array. When not
    given, the full sky is gridded.

    The grid is dependent on the field of view. When there are no
    pointings passed to the function, the field of view in combination
    with the overlap parameter, sets the gridding in RA and dec.

    Parameters
    ----------

    nsides : int or list of ints

        One or more nside parameters for which to calculate the
        HEALpix pixel lists for each tile.

        Usual values are 128, 256 or 512. All three could be given as
        [128, 256, 512].


    fov : dict with 'ra' and 'dec' keys

        Field of view along RA and dec

    overlap : dict with 'ra' and 'dec' keys

        Amount of overlap between tiles, along RA and dec. Should be a
        value between 0 and 0.9 for each direction.

    force : bool (default: False)

        Overwrite output file if it exists

    pointings : SkyCoord (default: None)

        List of pointings. If None, grid the full sky

    """

    if not force and os.path.lexists(filename):
        sys.exit("{} already exists; not overwritten".format(filename))

    tiles = {}
    for nside in nsides:
        tiles[nside] = tileallsky2(
            fov, nside, overlap=overlap, gridcoords=pointings, nested=True)

    with gzip.GzipFile(filename, 'w') as fp:
        pickle.dump(tiles, fp, protocol=2)
    logging.debug("Finished writing %s", filename)


def main():
    args = parse_args()
    logging.basicConfig(level=['WARNING', 'INFO', 'DEBUG'][args.verbose],
                        format='%(asctime)s [%(levelname)s]: %(message)s',
                        datefmt='%Y-%m-%dT%H:%M:%S')
    fov = {'ra': args.fov_ra * units.degree if args.fov_ra else None,
           'dec': args.fov_dec * units.degree if args.fov_dec else None}
    overlap = {'ra': args.ra_overlap, 'dec': args.dec_overlap}

    if args.pointings:
        pointings = np.loadtxt(args.pointings)
        pointings = SkyCoord(pointings, unit=units.degree)
    else:
        pointings = None

    if args.telescopes:
        for telescope in args.telescopes:
            fov['ra'] = telescope.fov['ra']
            fov['dec'] = telescope.fov['dec']
            dirname, filename = os.path.split(args.output)
            filename = telescope.name + '_' + filename
            filename = os.path.join(dirname, filename)

            create_gridfile(args.nside, fov, overlap, filename, args.force,
                        pointings=pointings)

    else:
        create_gridfile(args.nside, fov, overlap, args.output, args.force)


if __name__ == "__main__":
    main()
