#! /usr/bin/env python

from __future__ import absolute_import, print_function, division

import argparse
import os,sys
from gototile import skymaptools as smt
from gototile import simtools as simt
from gototile import scopetools as sct
from gototile import grid
from gototile import fits
import glob
import numpy as np
import healpy as hp
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from collections import Counter
from math import sin,cos,atan2,sqrt,pi,radians,log10
import astropy.coordinates as acoord
import astropy.units as u
import astropy.time

wcolora = '#511c6c'
wcoloro = '#f26322'
NSIDE=256

def tilefiles(out, tiles, simpath):


    oldfiles = glob.glob('{0}/*.txt'.format(out))
    [os.remove(fold) for fold in oldfiles]
        
    infiles = sorted(glob.glob('{0}/*.txt'.format(tiles)))    

    for fname in infiles:
        
        fsplit = fname.split('_')
        injid = fsplit[0][fsplit[0].rfind('/')+1:]
        scope = fsplit[1][:-4]
        delns, delew, lat, lon, height = sct.getscopeinfo(scope)
    
        inj,year = simt.findinj(injid,simpath)

        rainj,decinj,distinj = inj['ra'],inj['dec'],inj['dist']
        tinj,pinj = smt.cel2sph(rainj,decinj)
        injpix = hp.ang2pix(NSIDE,tinj,pinj,nest=True)
    
        outfile = "{0}/{1}_{2}.txt".format(out,year,scope)
        
        ras,decs,probs,tprobs,fprobs,ftprobs = np.genfromtxt(fname,
													delimiter=',',unpack=True)
        fnametiles = fname.replace('txt','pgz')
        tilelist,pixlist = grid.readtiles(fnametiles)

        if isinstance(probs,np.float64):
            visprob = ftprobs
            max = 1
            fifty = 1
            tile = tilelist
            if injpix in set(pixlist): tileinj = 1
            else: 
                tileinj=-1
                probinj=-1
        else:
            max = len(probs)
            visprob = probs[0]/fprobs[0]
            tilenum = 0
            tileinj = -1
            probinj=-1

            for tilenum,[ra,dec,prob] in enumerate(zip(ras,decs,probs)):
                
                if (ftprobs[tilenum])<0.5 and ((ftprobs[tilenum+1]))>0.5: 
                    fifty = tilenum
        
                if injpix in set(pixlist[tilenum]): 
                    tileinj = tilenum+1
                    probinj = tprobs[tilenum]
                    fprobinj = ftprobs[tilenum]
                    
        f = open(outfile, 'a')
        f.write("{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9} \n".format(
                injid, fifty, max, rainj, decinj, distinj, 
                tileinj, probinj, fprobinj, visprob))
        f.close()

def visibleinj(injid, simpath, scope, date):
    scopename = sct.getscopename(scope)
    delns, delew, lat, lon, height = sct.getscopeinfo(scopename)
    observatory = acoord.EarthLocation(lat=lat*u.deg, lon=lon*u.deg, 
        height=height*u.m)
    radius = 75.
    inj,year = simt.findinj(injid,simpath)
    date = astropy.time.Time(inj['mjd'],format='mjd') if date is None else date
    sidtimes = smt.siderealtimes(lat, lon, height, date)
    latr = radians(float(lat))
    
    seen = False
    ra = inj['ra']
    dec = inj['dec']
    for st in sidtimes:
        frame = acoord.AltAz(obstime=st, location=observatory)
        
        radec = acoord.SkyCoord(ra=ra*u.deg, dec=dec*u.deg)
        altaz = radec.transform_to(frame)
        
        if altaz.alt.degree>(90-radius): 
            #print(alt)
            seen = True
            break

    return seen    
    

    
def angsep(ra1,dec1,ra2,dec2):
    
    r1 = ra1*pi/180.
    d1 = dec1*pi/180.
    r2 = ra2*pi/180.
    d2 = dec2*pi/180.
    
    dra = abs(r1-r2)
    
    t = sqrt((cos(d2)*sin(dra))**2+
        (cos(d1)*sin(d2)-sin(d1)*cos(d2)*cos(dra))**2)
    b = sin(d1)*sin(d2) + cos(d1)*cos(d2)*cos(dra)
    
    ang = atan2(t,b)
    
    return ang*180/pi
    
def max2inj_dists(injids, simpath, year, out):
    
    angdists = []
    for idx,injid in enumerate(injids):
        fname = '{0}/{1}_fits/{2}/bayestar.fits.gz'.format(simpath,year,
                                                    int(injid))
        skymap, metadata = fits.read_sky_map(fname)
        orderin = 'NESTED' if metadata['nest'] else 'RINGED'
        newmap = hp.ud_grade(skymap, nside_out=NSIDE, order_in=orderin,
                             order_out='NESTED', power=-2)
        metadata['nest'] = True
        metadata['nside'] = NSIDE
        _,oidx = smt.orderedpixels(newmap)
        
        tmax,pmax = hp.pix2ang(NSIDE,oidx[0],nest=metadata['nest'])
        ramax,decmax = smt.sph2cel(tmax,pmax)
        
        inj,_=simt.findinj(injid,simpath)

        angdists.append(angsep(ramax,decmax,inj['ra']*15.,inj['dec']))
        
    fig = plt.figure()
    fig.clf()
    
    plt.hist(angdists,100, histtype='stepfilled',color=wcolora)
    plt.xlabel('Distance from loudest pixel to true source location (degrees)')
    plt.savefig('{}/{}_inj2maxdist.png'.format(out,year))
    plt.close()
    
    return
    
def angdisttiles(tiles, scope, out, year):

    infiles = sorted(glob.glob('{0}/*.txt'.format(tiles)))
    angdists = []
    
    scopename = sct.getscopename(scope)
    
    for fname in infiles:
        fsplit = fname.split('_')
        injid = fsplit[0][fsplit[0].rfind('/')+1:]
        scope = fsplit[1][:-4]
        
        if scope == scopename:
            ras,decs,_,_,_,_= np.genfromtxt(fname,delimiter=',',unpack=True)
            
            try:
                for idx,_ in ras[:-1]:
                    angdists.append(angsep(ras[idx],decs[idx],ras[idx+1],
                                    decs[idx+1]))
            except TypeError:
                angdists.append(angsep(ras[0],decs[0],ras[1],decs[1]))
            except IndexError:
                pass
    fig = plt.figure()
    fig.clf()
    
    plt.hist(angdists,100,range = [0,20], histtype='stepfilled',color=wcolora)
    plt.xlabel('Average distance between successive tiles')
    plt.savefig('{}/{}_{}_tiledists.png'.format(out,year,scopename))
    plt.close()
    
    return
    
def readpostfiles(first, out, tiles, simpath, scope, visible, tiledists,
                injdists, mags, maglim, exptime, date, lc):

    if first: tilefiles(out=out, tiles=tiles, simpath=simpath)

    scopename = sct.getscopename(scope)
    postfiles = sorted(glob.glob('{0}/*{1}.txt'.format(out,scopename)))
    for pfile in postfiles:
        s1 = pfile.split('/')
        s2 = s1[-1].split('_')
        year = s2[0]
        print(year)
    
        year = year 
        
        ids,fifties,nineties,ras,decs,dists,injtiles,injprobs,injfprobs, \
            visprobs = np.genfromtxt(pfile,delimiter=',',unpack=True)
            
        if injdists: 
            max2inj_dists(injids=ids, simpath=simpath, year=year, out=out)
        if tiledists: angdisttiles(tiles=tiles, scope=scope, out=out, year=year)
        
        print("Counting for {0}".format(pfile))
        cnt = Counter(injtiles)
        print("Total number of injections triggered: {}".format(len(injtiles)))
        print("GW location covered in {} injections of those triggered".format(
                                    len(injtiles)-cnt[-1.0]))
        print("GW location covered {}% of the time".format(
                    (1-((float(cnt[-1.0])/float(len(injtiles)))))*100.0))
        if visible:
            totalseen = len(injtiles)-cnt[-1.0]
            vis = 0
            for idx,injtile in enumerate(injtiles):
        
                seen=False
                if injtile<0.: seen = visibleinj(ids[idx],simpath,scope,date)
                if seen: vis+=1
            print("Number of those not found that are above horizon: "
                        "{}".format(vis))
            print("GW location visible but not observed {:2.3f}% of the "
                "time".format((float(vis)/(float(totalseen)+float(vis)))*100.))
        
        
        if mags:
            maglist = []
            for idx,injtile in enumerate(injtiles):
                if injtile>0.0: 
                    brightmag = injmag(dists[idx],lc)
                    
                    if brightmag<maglim: maglist.append(brightmag)
                    
                    
            print("Number of those correctly tiled that have one or more "
                "kilonova models above limiting mag: {}".format(len(maglist)))
        fiftyhist = np.histogram(fifties,bins=10)
    
        fig = plt.figure()
        fig.clf()
    
        plt.hist(injtiles, 100, range=[0,max(injtiles)], histtype='stepfilled',
                        cumulative=True, normed=1,color=wcolora)
        plt.xlabel('Tile number containing true source location')
        plt.ylabel('Fraction below ordinate')
        plt.ylim((0,1))
        plt.savefig('{}/{}_{}_injtilecum.png'.format(out,year,
                    scopename))
        plt.close()
        
        fig = plt.figure()
        fig.clf()
    
        plt.hist(injtiles, 100, range=[0,max(injtiles)+5], 
            histtype='stepfilled', cumulative=False,color=wcolora)
        plt.xlabel('Tile number containing true source location')
        plt.savefig('{}/{}_{}_injtile.png'.format(out,year,
                       scopename))
        plt.close()
        
        fig = plt.figure()
        fig.clf()
    
        plt.hist(visprobs, 100, range=[0,1], histtype='stepfilled', 
                    cumulative=False,color=wcolora)
        plt.xlabel('Distribution of visible skymap probability')
        plt.savefig('{}/{}_{}_visprob.png'.format(out,year,
                    scopename))
        plt.close()
        
        fig = plt.figure()        
        fig.clf()
        plt.hist(injtiles*exptime, 100, range=[0,max(injtiles*5.)], 
                    histtype='stepfilled',color=wcolora)
        plt.xlabel('Observing time needed to tile true source location '
                    '(minutes)')
        plt.savefig('{}/{}_{}_injobstime.png'.format(out,year,
                    scopename))
        plt.close()
        
        fig = plt.figure()        
        fig.clf()
        plt.hist(injtiles*exptime, 100, range=[0,max(injtiles*5.)], 
                histtype='stepfilled', cumulative=True, normed=1,color=wcolora)
        plt.xlabel('Observing time needed to tile true source location '
                    '(minutes)') 
        plt.ylabel('Fraction below ordinate')
        plt.ylim((0,1))
        plt.savefig('{}/{}_{}_injobstimecum.png'.format(out,year,
                        scopename))
        plt.close()
        
        fig = plt.figure()        
        fig.clf()
        plt.scatter(injtiles,injprobs,color=wcolora)
        plt.xlim((0,max(injtiles)+5))
        plt.ylim((0,1))
        plt.xlabel('Tile number containing true source location')
        plt.ylabel('Probability searched to image true source location')
        plt.savefig('{}/{}_{}_injvsprobs.png'.format(out,year,
                        scopename))
        plt.close()
        
        fig = plt.figure()        
        fig.clf()
        plt.scatter(injtiles,fifties,color=wcolora)
        xs = [0,10,20,50,100]
        ys = xs
        plt.plot(xs,ys)
        plt.xlim((0,max(injtiles)+5))
        plt.ylim((0,max(fifties)+5))
        plt.xlabel('Tile number containing true source location')
        plt.ylabel('Number of tiles needed to image at least 50% of GW '    
                    'probability')
        plt.savefig('{}/{}_{}_injvsfifty.png'.format(out,year,
                        scopename))
        plt.close()
    
        ratios = [inj-fifty for inj,fifty in zip(injtiles,fifties)]
        fig = plt.figure()
        fig.clf()
        plt.hist(ratios,100,range=[-50,50], histtype='stepfilled',color=wcolora)
        plt.close()
    
        fig = plt.figure()
        fig.clf()
        plt.hist(injprobs,100,range=[0,1], histtype='stepfilled',color=wcolora)
        plt.xlabel('Probability searched to image tile containing source')
        plt.savefig('{}/{}_{}_injprobs.png'.format(out,year,
                    scopename))
        plt.close()
    
        fig = plt.figure()
        fig.clf()
        plt.hist(injprobs, 100, range=[0,1], histtype='stepfilled',
                    cumulative=True,normed=1,color=wcolora)
        plt.minorticks_on()
        plt.grid(which='both')
        plt.xlim((0,1))
        plt.ylim((0,1))
        plt.xlabel('Cumulative probability searched to image tile '
                    'containing source')
        plt.savefig('{}/{}_{}_cuminjprobs.png'.format(out,year,
                        scopename))
        plt.close()

    return
    
def injmag(dist,lc):
    dmod = 5*log10(dist*1e6)-5
    t,g1,g2 = np.genfromtxt('{}/bp_CaFN_mv_m_mags.txt'.format(lc), 
                                skip_header=1,unpack = True)
    return min(g2+dmod)
    
def parse_command_line():
    
    description = ("This script creates pointings for selected telescopes, "
                   "with given skymap files.")

    parser = argparse.ArgumentParser(
        description = description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    
    parser.add_argument("--first", action="store_true", default=False,
                help="Make tilefiles?")
    parser.add_argument("--out", help="Output folder for plots and text files")
    parser.add_argument("--tiles", default='./',
                        help=("Location of f2y tiling algorithm output"))
    parser.add_argument("--simpath", default='/storage/astro2/phsnap/Skymaps',
                help="Input folder containing original first2years simulations")
    parser.add_argument("--lc", 
            default='/storage/astro2/phsnap/lightcurves/GOTO/ns_merger_mags/',
            help="Input folder containing kilonova lightcurve simulations")
    parser.add_argument("-s", "--scope", choices=['g4', 'g8', 'swn', 'v'],
                        default='g4',
                        help=("Telescope to use. GOTO-4, GOTO-8, "
                              "SuperWASP-North, VISTA."))    
    parser.add_argument("--tiledists", action="store_true", default=False,
                   help="Find angular distances between successive tiles")
    parser.add_argument("--injdists", action="store_true", default=False,
                help="Find angular distances between injection location and "
                "loudest pixel")
    parser.add_argument("--visible", action="store_true", default=False,
                help="Check number of injections above horizon")
    parser.add_argument("--mags", action="store_true", default=False,
                help="Check number of injections above limiting mag")     
    parser.add_argument("--maglim", metavar="MAGLIM", default=21.0,
                help="Limiting magnitude above which kilonova is visible")
    parser.add_argument("--exptime", metavar="EXPTIME", default=5.0,
                help="Exposure time in mins of observations (used for working "
                "out total time for all tiles)")
    parser.add_argument("-d", "--date", nargs='?', default='now',
                        help="Set observation date. If not used, defaults to "
                        "the current date.  If given without argument, "
                        "defaults to the trigger date in the input file(s). "
                        "The optional "
                        "argument can be a date-time string that can be parsed "
                        "by astropy.time.Time, such as '2012-12-12T12:12:12'. "
                        "A single number is interpreted as Julian days; use a "
                        "number with 'mjd' appended to specify Modified Julian "
                        "Days.")

    return parser.parse_args()

def parse_date(string):
    """Turn a string into an astropy.time.Time date"""
    if string is None:
        return None
    if string == 'now':
        return Time.now()
    if string.lower().endswith('jd'):
        if string.lower().endswith('mjd'):
            return Time(float(string[:-3]), format='mjd', scale='utc')
        return Time(float(string[:-2]), format='jd', scale='utc')
    return Time(string)
    
if __name__ == '__main__':

    args = parse_command_line()
    if not os.path.exists(args.out):
        os.makedirs(args.out)
    args.date = parse_date(args.date)
    readpostfiles(first=args.first, out=args.out, tiles=args.tiles, 
    simpath=args.simpath, scope=args.scope, visible=args.visible, 
    tiledists=args.tiledists, injdists=args.injdists, mags=args.mags, 
    maglim=args.maglim, exptime=args.exptime, date=args.date, lc=args.lc)


